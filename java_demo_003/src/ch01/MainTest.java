package ch01;

/**
 * 
 *     가장 유명한 디자인 패턴 중 하나인 팩토리 패턴입니다.
 * 	<<팩토리 패턴 (팩토리 메서드 패턴 : Factory Method Pattern)>>
 *  # 팩토리 패턴은 생성 패턴 중에 하나입니다.
 *
 *  - 생성 패턴은 인스턴스를 만드는 절차를 추상화 하는 패턴이다.
 *	- 생성 패턴에 속하는 패턴들은 객체를 생성, 합성하는 방법이나 객체의 표현 방법을 시스템과 분리해준다.
 *	- 생성 패턴은 시스템이 상속보다 복합 방법을 사용하는 방향으로 진화되어 가면서 중요성이 더해지고 있다.
 *	
 *
 *	# 생성 패턴에서는 중요한 이슈 2가지가 있다.
 *	- 생성 패턴은 시스템이 '어떤 Concrete Class(구체적인 클래스)'를 사용하는지에 대한 정보를 캡슐화 한다.
 *	- 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들어지고 어떻게 결합되는지에 대한 부분을 완전히 가려준다.
 *
 *	# 즉 팩토리 패턴이란?
 *	- 팩터리 패턴은 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브클래스 쪽에서 내리는 패턴이다.
 *	=> 다시 말해, 여러개의 서브클래스를 가진 슈퍼 클래스가 있을 때, 인풋에 따라 하나의 자식클래스를 인스턴스해서 리턴해 주는 방식이다.
 *
 * 	# "이렇게 설계해야 하지만, , 디테일은 너가 설계해"
 *  -*** 팩토리패턴에서는 클래스의 인스턴스를 만드는 시점을 서브 클래스로 미룬다.!!!!
 *  
 *  # 활용성(어떨때 팩토리패턴을 사용하나)
 *  - 어떤 클래스가 자신이 생성해야하는 객체의 클래스를 예측할 수 없을 때.
 *  - 생성할 객체를 기술하는 책임을 자신이 아니고 서브클래스가 가졌으면 할 때 사용. 
 *  
 *  # 팩토리 패턴의 장점
 *  - 팩토리 패턴은 클라이언트 코드로부터 서브 클래스의 인스턴스화를 제거하여 서로간의 종속성을 낮추고, 결합도를 느슨하게 하며 확장을 쉽게 한다.
 *  - pc클래스에 대해서 수정 혹은 삭제가 일어나더라도 클라이언트는 알 수 없기 때문에 코드를 변경할 필요도 없다.
 *  - (여기서 MainTest이 코드가 클라이언트 코드라고 가정한다.)
 *  - 팩토리 패턴은 클라이언트와 구현 객체들 사이에 추상화를 제공한다.
 * 
 */


public class MainTest {
    public static void main(String[] args) {
    	
    	// 객체를 생성시킴. 어떤 객체를 생성시키는지 감춰져 있지만 type에 따라 다르게 생성된다.
    	// 이 시점에 객체가 생성되고, 구현은 서브클래스에게 있음 => 종속성 down, 결합도 down, 확장성 up 
    	// => 유지보수편리 up, 클라이언트와 구현 객체들 사이에 추상화 제공.
    	
    	// PC pc = new PC();이런거 안하잖아.
    	Computer computer = ComputerFactory.getComputer("PC", "32", "1TB", "ARM"); 
    	System.out.println(computer);
    	
    	//일관성있는 메서드 사용으로 가독성 올라가고
    	// 내부적으로 어떻게 객체가 생겨나는지 감춰져서 캡슐화됨.
    	Computer computer2 = ComputerFactory.getComputer("NoteBook", "16", "500", "Intel");
    	System.out.println(computer2);
    }
}